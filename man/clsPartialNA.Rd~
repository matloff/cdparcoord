\name{clsPartialNA}
\alias{clsPartialNA}
\alias{discparcoord}


\title{
    Compute/display tuple frequency counts, and optionally account for NA values
    in parallel.
}

\usage{
    tupleFreqs(dataset,k=5,NAexp=1.0,countNAs=FALSE,saveCounts=TRUE, 
       minFreq=NULL) 
    clsPartialNA(cls=NULL, dataset, k=5, NAexp=1, countNAs=FALSE)
    discparcoord(data, k=5, grpcategory=NULL, permute=FALSE,
        interactive = TRUE, save=FALSE, name="Parcoords", labelsOff=TRUE,
        NAexp=1.0,countNAs=FALSE, accentuate=NULL, accval=100, inParallel=FALSE,
        cls=NULL, differentiate=FALSE, saveCounts=TRUE, minFreq=NULL)
}

\description{
    The function \code{tupleFreqs} determines the set of unique tuples,
    and computes a count for each; \code{clsPartialNA} does the same,
    but in parallel.  The \code{k} most- or least-frequent tuples will
    be reported, with the latter specified via negative \code{k}.
    Optionally, tuples with NA values will count less, but weigh 
    toward everything that has existing numbers in common with it.
}

\arguments{
    \item{cls}{
        The cluster to use to process. If not supplied, 
        it generates its own cluster.
    }
    \item{dataset}{
        The dataset to process, a data frame or data.table.
    }
    \item{k}{
        The number of tuples to return. These will be the \code{k} most
        frequent tuples, unless \code{k} is negative, in which case the
        least-frequent tuples will be returned.  The latter is useful
        for hunting for outliers.
    }
    \item{NAexp}{
        Scale NA signifiance. This is experimental and may be extremely slow.
    }
    \item{countNAs}{
        Whether or not you want to count NA values.
    }
}

\author{
    Norm Matloff <matloff@cs.ucdavis.edu>, Vincent Yang <vinyang@ucdavis.edu>, 
    and Harrison Nguyen <hhnguy@ucdavis.edu>
}

\details{
    This is the workhorse function in the package, calculating frequency
    counts to be used in the graphs.

    The data will be converted into a data.table if it is not already in
    that form.  For this and other reasons, it is advantageous to have the
    data in that form to begin with, say by using \code{fread} to read the data.

    Optionally, tuples that partially match a full tuple pattern except for NA
    values will add a partial count to the frequency count for the full
    pattern.  If for instance the data consist of 8-tuples and a row in the
    data matches a given 8-tuple pattern in 7 of 8 components, this row
    would add a count of 7/8 to the frequency for that pattern.  To reduce
    this weight, use a value greater than 1.0 for \code{NAexp}.  If that
    value is 2, for example, the 7/8 increment will be 7/8 squared.
}

\examples{
    data(Titanic_Passengers)
    # Find frequencies in parallel
    discparcoord(Titanic_Passengers, inParallel=TRUE)
}

\title{
    Top-frequency parallel coordinates plots.
}

\description{
    A novel approach to the parallel coordinates method for 
    visualization of multiple variables at once, focused on discrete 
    and categorical variables.

    (a) Addresses the screen-clutter problem in parallel coordinates, by
    only plotting the "most typical" cases. These are the tuples with 
    the highest occurrence rates.

    (b) Provides a novel approach to NA values by allowing tuples 
    with NA values to partially contribute to complete tuples rather 
    than eliminating missing values.

}

\arguments{
    \item{data}{
        The data, in data frame or matrix form.
    }
    \item{k}{
        The number of lines to display in the parallel coordinates plot.
    }
    \item{grpcategory}{
        Grouping column/variable.
    }
    \item{permute}{
        If TRUE, randomly permute the columns before plotting.
    }
    \item{interactive}{
        If TRUE, use interactive plotting, allowing for interactively
        readjusting column order and scrubbing/brushing. 
    }
    \item{save}{
        If this is TRUE and interactive mode is on, saved plot
        will be available from the browser.
    }
    \item{name}{
        The name for the plot.
    }
    \item{labelsOff}{
        If TRUE, labels are off. This only comes into
        effect when interactive=FALSE.
    }
    \item{NAexp}{
        Scale for NA counts.
    }
    \item{countNAs}{
        If TRUE, count NA values.
    }
    \item{accentuate}{
        Character expression specifying the property to accentuate.
    }
    \item{accval}{
        The value to accentuate. By default, this is 100.
    }
    \item{inParallel}{
        If TRUE, calculate tuple frequencies in parallel. 
    }
    \item{cls}{
        Cluster to be used if \code{inParallel} is TRUE.  If
        \code{inParallel} is TRUE and \code{cls} is not supplied, 
        it will use the sensed number of cores on the calling machine 
        by default. 
    }
    \item{differentiate}{
       If TRUE, randomize coloring to differentiate overlapping
       lines. 
    }
    \item{saveCounts}{
        If TRUE, save the tuple counts to the file \code{tupleCounts}.
    }
    \item{minFreq}{
        The smallest frequency to be displayed.
    }
}

\details{ 

Parallel coordinates plots allow the user to see the relationships
between many different variables on the same graph. It can be thought of
as a scatter graph that extends beyond just two variables. 

For example, if we had three variables Height, Weight and Age, each
variable would have its own vertical axis. Each point then "connects the
dots" on the vertical axes. For instance, (70, 160, 28) would be a
segmented line that has 70 on the Height axis, 160 on the Weight axis,
and 28 on the Age axis. 

An example of this is \code{parcoord}, found in the MASS package.
One of the issues with parallel coordinates is that if there are too
many lines, the screen will be cluttered, hence a "black screen problem."

The package \code{freqparcoord} addresses this for continuous
variables; \code{discparcoord} fixes the problem when dealing with discrete
or categorical
variables by plotting only the most occuring tuples. 

The other problem that discparcoord addresses is the occurrence of NA
values in dataset.  Usually, there are two solutions to this problem:
either ignore the entire tuple, or use various models to predict what
the values would be based on all the other data (imputation). Instead of
using either of these, we take partial values of incomplete tuples and
then add those values to complete matching tuples. For example, given a
tuple (1, 2, NA) and (1, 2, 3), the final count of tuples would be (1,
2, 3), occurring 1.66 times. The incomplete tuple is only counted for
2/3.  

} 

\value{
    Object of type "graph".
}

\author{
    Norm Matloff <matloff@cs.ucdavis.edu>, Vincent Yang <vinyang@ucdavis.edu>, and Harrison Nguyen <hhnguy@ucdavis.edu>
}

\examples{
    data(hrdata)
    input1 = list("name" = "average_montly_hours",
                  "partitions" = 3, "labels" = c("low", "med", "high"))
    input = list(input1)
    # this will discretize the data by partitioning average monthly 
    # hours into 3 parts called low, med, and high
    hrdata = discretize(hrdata, input)
    # account for NA values and plot with parallel coordinates
    discparcoord(hrdata)

    # same as above, but with scrambled columns
    discparcoord(hrdata, permute=TRUE)

    # same as above, but show top k values
    discparcoord(hrdata, k=8)

    # same as above, but group according to profession
    discparcoord(hrdata, grpcategory="sales")

